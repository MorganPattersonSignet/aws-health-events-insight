---
AWSTemplateFormatVersion: '2010-09-09'
Description: (AwsHealthEvents) Stack to create Enrich Event via AWS Config.
Parameters:
  ConfigurationAggregatorName:
    Type: String
    Description: Configuration Aggregator Name
  ConfigurationAggregatorRegion:
    Type: String
    Description: Configuration Aggregator Region
  ConfigurationAggregatorAccount:
    Type: String
    Description: Configuration Aggregator Region, Leave empty if Aggregator in same account

Resources:
  AWSHealthEventEnrichLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole 
      Policies:
        - PolicyName: cloudwatch-logsAccess-Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                Resource: !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:*"
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
        - PolicyName: AwshealtheventConfig-Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - config:SelectAggregateResourceConfig
                Resource: "*"
        - !If
          - ConfigurationAggregatorAccount
          - PolicyName: ConfigAccountAssumeRole-Policy
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: Allow
                  Action:
                  - sts:AssumeRole
                  Resource: !Sub arn:${AWS::Partition}:iam::${ConfigurationAggregatorAccount}:role/HeidiDataCollection-ConfigCrossAccount-Role
          - !Ref "AWS::NoValue"

  AWSHealthEventEnrichLambdaSameAccount:
    Condition: ConfigurationAggregatorFunction
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: "Given AWSLambda ExecutionRole and allows Cloudwatch"
    Properties: 
      Code:
        ZipFile: |
          import boto3
          import json
          import base64
          import os

          def get_resource_tags(resource_id, event_region):
              try:
                  config_client = boto3.client('config', region_name=(os.environ['ConfigurationAggregatorRegion']))
                  expression = f"SELECT configuration.*, tags.key, tags.value WHERE resourceID = '{resource_id}' or resourceName = '{resource_id}' or arn = '{resource_id}' and awsRegion = '{event_region}'"
                  response = config_client.select_aggregate_resource_config(Expression=expression, ConfigurationAggregatorName=(os.environ['ConfigurationAggregatorName']))
                  entityTags, entityArn, entityAZ = None, None, None
                  if len(response.get('Results', [])) > 1:
                    return None, None, None
                  else:
                    for result in response.get('Results', []):
                        try:
                            config_data = json.loads(result)
                            entityTags = config_data.get('tags', entityTags)
                            entityArn = config_data.get('arn', entityArn)
                            entityAZ = config_data.get('availabilityZone', entityAZ)
                        except Exception as e:
                            print("Error parsing JSON:", e)
                    return entityTags, entityArn, entityAZ
              except Exception as e:
                  print("Error fetching resource config:", e)
                  return None, None, None

          def add_tags_to_entity(entity, entityArn, entityTags, entityAZ):
              if entityArn:
                  entity["entityArn"] = entityArn
              if entityAZ:
                  entity["entityAZ"] = entityAZ
              if entityTags:
                  entity["entityTags"] = entityTags

          def lambda_handler(event, context):
              print(event)
              output = []
              for record in event.get('records'):
                  payload = base64.b64decode(record['data']).decode('utf-8')
                  event_data = json.loads(payload)
                  event_detail = event_data['detail']
                  event_region = event_detail['eventRegion']
                  for entity in event_detail.get("affectedEntities", []):
                      resource_id = entity.get("entityValue")
                      entityTags, entityArn, entityAZ = get_resource_tags(resource_id, event_region)
                      if entityTags is not None or entityArn is not None or entityAZ is not None:
                          add_tags_to_entity(entity, entityArn, entityTags, entityAZ)
                  print(json.dumps(event_data))
                  output_record = {
                      'recordId': record.get('recordId', ''),
                      'result': 'Ok',
                      'data': base64.b64encode(json.dumps(event_data).encode('utf-8')).decode('utf-8')
                  }
                  output.append(output_record)
              print('Successfully processed {} records.'.format(len(event.get('records', []))))
              return {'records': output}

      Handler: index.lambda_handler
      Runtime: python3.10
      Timeout: 900
      ReservedConcurrentExecutions: 5
      Role: !GetAtt AWSHealthEventEnrichLambdaRole.Arn
      Environment:
        Variables:
          ConfigurationAggregatorName: !Ref ConfigurationAggregatorName
          ConfigurationAggregatorRegion: !Ref ConfigurationAggregatorRegion

  AWSHealthEventEnrichLambdaCrossAccount:
    Condition: ConfigurationAggregatorAccount
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: "Given AWSLambda ExecutionRole and allows Cloudwatch"
    Properties: 
      Code:
        ZipFile: |
          import boto3
          import json
          import base64
          import os

          def get_resource_tags(resource_id):
              try:
                  sts_connection = boto3.client('sts')
                  Config_Acc = sts_connection.assume_role(RoleArn=(os.environ['ConfigAccountRole']),RoleSessionName="AWSHealthEventEnrichLambdaCrossAccount")
                  ACCESS_KEY = Config_Acc['Credentials']['AccessKeyId']
                  SECRET_KEY = Config_Acc['Credentials']['SecretAccessKey']
                  SESSION_TOKEN = Config_Acc['Credentials']['SessionToken']

                  config_client = boto3.client('config', region_name=(os.environ['ConfigurationAggregatorRegion']), aws_access_key_id=ACCESS_KEY, aws_secret_access_key=SECRET_KEY, aws_session_token=SESSION_TOKEN,)
                  expression = f"SELECT configuration.*, tags.key, tags.value WHERE resourceID = '{resource_id}' or resourceName = '{resource_id}' or arn = '{resource_id}' and awsRegion = '{event_region}'"
                  response = config_client.select_aggregate_resource_config(Expression=expression, ConfigurationAggregatorName=(os.environ['ConfigurationAggregatorName']))
                  entityTags, entityArn, entityAZ = None, None, None
                  if len(response.get('Results', [])) > 1:
                    return None, None, None
                  else:
                    for result in response.get('Results', []):
                        try:
                            config_data = json.loads(result)
                            entityTags = config_data.get('tags', entityTags)
                            entityArn = config_data.get('arn', entityArn)
                            entityAZ = config_data.get('availabilityZone', entityAZ)
                        except Exception as e:
                            print("Error parsing JSON:", e)
                    return entityTags, entityArn, entityAZ
              except Exception as e:
                  print("Error fetching resource config:", e)
                  return None, None, None

          def add_tags_to_entity(entity, entityArn, entityTags, entityAZ):
              if entityArn:
                  entity["entityArn"] = entityArn
              if entityAZ:
                  entity["entityAZ"] = entityAZ
              if entityTags:
                  entity["entityTags"] = entityTags

          def lambda_handler(event, context):
              print(event)
              output = []
              for record in event.get('records'):
                  payload = base64.b64decode(record['data']).decode('utf-8')
                  event_data = json.loads(payload)
                  event_detail = event_data['detail']
                  event_region = event_detail['eventRegion']
                  for entity in event_detail.get("affectedEntities", []):
                      resource_id = entity.get("entityValue")
                      entityTags, entityArn, entityAZ = get_resource_tags(resource_id, event_region)
                      if entityTags is not None or entityArn is not None or entityAZ is not None:
                          add_tags_to_entity(entity, entityArn, entityTags, entityAZ)
                  print(json.dumps(event_data))
                  output_record = {
                      'recordId': record.get('recordId', ''),
                      'result': 'Ok',
                      'data': base64.b64encode(json.dumps(event_data).encode('utf-8')).decode('utf-8')
                  }
                  output.append(output_record)
              print('Successfully processed {} records.'.format(len(event.get('records', []))))
              return {'records': output}

      Handler: index.lambda_handler
      Runtime: python3.10
      Timeout: 900
      ReservedConcurrentExecutions: 5
      Role: !GetAtt AWSHealthEventEnrichLambdaRole.Arn
      Environment:
        Variables:
          ConfigurationAggregatorName: !Ref ConfigurationAggregatorName
          ConfigurationAggregatorRegion: !Ref ConfigurationAggregatorRegion
          ConfigAccountRole: !Sub arn:${AWS::Partition}:iam::${ConfigurationAggregatorAccount}:role/HeidiDataCollection-ConfigCrossAccount-Role

Outputs:
  AWSHealthEventEnrichLambdaArn:
    Value: !If [ConfigurationAggregatorFunction, !GetAtt AWSHealthEventEnrichLambdaSameAccount.Arn, !GetAtt AWSHealthEventEnrichLambdaCrossAccount.Arn]
    Export:
      Name:   AWSHealthEventEnrichLambdaArn
  AWSHealthEventEnrichLambdaRole:
    Value: !GetAtt AWSHealthEventEnrichLambdaRole.Arn
    Export:
      Name:   AWSHealthEventEnrichLambdaRoleArn
  
Conditions:
  ConfigurationAggregatorAccount: !Not [!Equals [!Ref ConfigurationAggregatorAccount, "N"]]
  ConfigurationAggregatorFunction: !Equals [!Ref ConfigurationAggregatorAccount, "N"]